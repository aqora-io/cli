use std::path::{Path, PathBuf};

use aqora_config::{AqoraSubmissionConfig, AqoraUseCaseConfig, PathStr, PyProject};
use aqora_runner::{
    pipeline::{
        clone_evaluation_result, EvaluationResult, EvaluatorState, Pipeline, PipelineConfig,
    },
    python::{PyEnv, PyEnvOptions},
};
use futures::TryStreamExt as _;
use pyo3::{
    exceptions::{PyIOError, PyIndexError, PyOverflowError, PyRuntimeError, PyValueError},
    prelude::*,
};

use crate::dirs::{project_data_dir, project_use_case_toml_path, read_pyproject};

/// An `ExperimentSubmission` is a submission handler that instantiates a submission pipeline
/// in order to run a specific layer.
pub struct ExperimentSubmission {
    /// which layer we are experimenting
    submission_layer: String,
    /// full pipeline are run experiments on
    pipeline: Pipeline,
    /// cache for all inputs generated by pipeline
    generated_input: Vec<PyObject>,

    inner: parking_lot::RwLock<Inner>,
}

struct Inner {
    /// pending evaluation
    pending: Option<PendingExperiment>,
    /// all aggregated results for multiple evaluations
    results: Vec<Option<EvaluationResult>>,
}

struct PendingExperiment {
    /// index of input we are experimenting
    input_index: usize,
    /// state of the pending evaluator
    eval_state: EvaluatorState,
    /// future experiment output, None by default
    output: PyObject,
}

impl ExperimentSubmission {
    pub async fn load_notebook() -> PyResult<Self> {
        let venv_path = Self::fetch_venv_path()?;
        let project_dir = venv_path
            .parent()
            .ok_or_else(|| {
                PyErr::new::<PyIOError, _>("cannot access parent of virtual env directory")
            })?
            .to_owned();

        let use_case = Self::load_use_case(project_dir.as_ref()).await?;
        let submission = Self::load_submission(project_dir.as_ref()).await?;
        let submission_layer = Self::fetch_notebook_layer(project_dir.as_ref(), &submission)?;
        let pipeline =
            Self::load_pipeline(venv_path.as_ref(), project_dir.as_ref(), &use_case).await?;
        let generated_input: Vec<PyObject> = Box::pin(pipeline.generator()?).try_collect().await?;
        let mut evaluated = Vec::new();
        evaluated.resize_with(generated_input.len(), Default::default);

        Ok(Self {
            submission_layer,
            pipeline,
            generated_input,
            inner: parking_lot::RwLock::new(Inner {
                pending: None,
                results: evaluated,
            }),
        })
    }

    fn fetch_venv_path() -> PyResult<PathBuf> {
        Python::with_gil(|py| {
            Ok(py
                .import("sys")?
                .getattr("prefix")?
                .extract::<String>()?
                .into())
        })
    }

    async fn load_use_case(project_dir: &Path) -> PyResult<AqoraUseCaseConfig> {
        let use_case_toml_path = project_use_case_toml_path(project_dir);
        let use_case_config =
            PyProject::from_toml(tokio::fs::read_to_string(use_case_toml_path).await?)
                .map_err(|_| PyErr::new::<PyValueError, _>("malformed use-case config"))?;
        use_case_config
            .into_aqora()
            .and_then(|aqora| aqora.into_use_case())
            .ok_or_else(|| PyErr::new::<PyRuntimeError, _>("expected project to be a use-case"))
    }

    async fn load_submission(project_dir: &Path) -> PyResult<AqoraSubmissionConfig> {
        let submission_config = read_pyproject(&project_dir)
            .await
            .map_err(|error| PyErr::new::<PyRuntimeError, _>(error.description()))?;
        submission_config
            .into_aqora()
            .and_then(|x| x.into_submission())
            .ok_or_else(|| PyErr::new::<PyRuntimeError, _>("expected project to be a submission"))
    }

    fn fetch_notebook_layer(
        project_dir: &Path,
        submission: &AqoraSubmissionConfig,
    ) -> PyResult<String> {
        let notebook_module = Python::with_gil(|py| ipython_notebook_module(py, project_dir))?
            .ok_or_else(|| PyErr::new::<PyRuntimeError, _>("notebook not found"))?;
        submission
            .refs
            .iter()
            .find_map(|(ref_name, ref_fn)| {
                if ref_fn.notebook && ref_fn.path == notebook_module {
                    Some(ref_name.clone())
                } else {
                    None
                }
            })
            .ok_or_else(|| PyErr::new::<PyRuntimeError, _>("notebook is not part of submission"))
    }

    async fn load_pipeline(
        venv_path: &Path,
        project_dir: &Path,
        use_case: &AqoraUseCaseConfig,
    ) -> PyResult<Pipeline> {
        let uv_path =
            which::which("uv").map_err(|error| PyErr::new::<PyIOError, _>(error.to_string()))?;
        let environment = PyEnv::init(uv_path, venv_path, PyEnvOptions::default())
            .await
            .map_err(|error| PyErr::new::<PyRuntimeError, _>(error.to_string()))?;
        let data_path = project_data_dir(project_dir);
        Pipeline::import(&environment, use_case, PipelineConfig { data: data_path })
    }
}

fn python_module_from_notebook_path(mut path: PathBuf) -> Option<PathStr<'static>> {
    if path
        .extension()
        .is_none_or(|extension| extension != "ipynb")
    {
        return None;
    }
    path.set_extension("");
    Some(PathStr::new(
        path.components()
            .map(|x| x.as_os_str().to_string_lossy().to_string())
            .skip_while(|x| x == "src"),
    ))
}

fn ipython_notebook_module(
    py: Python<'_>,
    project_dir: impl AsRef<Path>,
) -> PyResult<Option<PathStr<'static>>> {
    let main = py.import(pyo3::intern!(py, "__main__"))?;
    for attr_name in [
        pyo3::intern!(py, "__file__"),
        pyo3::intern!(py, "__vsc_ipynb_file__"),
        pyo3::intern!(py, "__session__"),
    ] {
        if let Ok(file_path) = main.getattr(attr_name) {
            let mut file_path = PathBuf::from(file_path.extract::<String>()?);
            if file_path.is_absolute() {
                file_path = file_path
                    .strip_prefix(project_dir)
                    .map_err(|error| PyErr::new::<PyIOError, _>(error.to_string()))?
                    .to_path_buf();
            }
            return Ok(python_module_from_notebook_path(file_path));
        }
    }
    Ok(None)
}

impl ExperimentSubmission {
    #[allow(clippy::await_holding_lock)]
    pub async fn load(&self, index: isize) -> PyResult<()> {
        let index = if index < 0 {
            self.generated_input
                .len()
                .checked_add_signed(index)
                .ok_or_else(|| PyErr::new::<PyOverflowError, _>(()))?
        } else {
            index as usize
        };

        let mut inner = self.inner.write();
        match &inner.pending {
            Some(pending) if pending.input_index != index => {
                return Err(PyErr::new::<PyRuntimeError, _>(
                    "cannot load another input until next set_output",
                ))
            }
            Some(_) => return Ok(()),
            None => {}
        };

        let (input, evaluator) = Python::with_gil(|py| {
            let input = self
                .generated_input
                .get(index)
                .map(|x| x.clone_ref(py))
                .ok_or_else(|| {
                    PyErr::new::<PyIndexError, _>(format!("input index out of range: {index}"))
                })?;
            let evaluator = self.pipeline.evaluator(py);
            PyResult::Ok((input, evaluator))
        })?;

        if self.generated_input.len() > 1 {
            println!(
                "Selected case {} (out of {})",
                index + 1,
                self.generated_input.len()
            );
        }

        let mut eval_state = EvaluatorState::new(input, None);
        while evaluator.can_reach_layer(&eval_state, self.submission_layer.as_str()) {
            evaluator.evaluate_layer(&mut eval_state).await?;
            if evaluator.layer_name(&eval_state) == self.submission_layer.as_str() {
                break;
            }
        }

        inner.pending = Some(PendingExperiment {
            input_index: index,
            eval_state,
            output: Python::with_gil(|py| py.None()),
        });

        Ok(())
    }

    #[allow(clippy::await_holding_lock)]
    pub async fn finish(&self) -> PyResult<()> {
        let mut inner = self.inner.write();

        let PendingExperiment {
            input_index: index,
            mut eval_state,
            output,
        } = inner
            .pending
            .take()
            .ok_or_else(|| PyErr::new::<PyRuntimeError, _>("not evaluating"))?;

        let evaluator = Python::with_gil(|py| self.pipeline.evaluator(py));
        evaluator.advance_layer(&mut eval_state, output).await?;
        while !evaluator.finished(&eval_state) {
            evaluator.evaluate_layer(&mut eval_state).await?;
        }

        let next_eval_result = eval_state.out; // forget eval_state and just keep result
        let prev_eval_result = inner.results[index].replace(Python::with_gil(|py| {
            clone_evaluation_result(py, &next_eval_result)
        }));
        let inner = parking_lot::RwLockWriteGuard::downgrade(inner);

        if let Some(prev_eval_result) = prev_eval_result {
            let next_metric = next_eval_result
                .values()
                .find_map(|layers| layers.iter().find_map(|layer| layer.metric.as_ref()))
                .filter(|x| !Python::with_gil(|py| x.is_none(py)));
            let prev_metric = prev_eval_result
                .values()
                .find_map(|layers| layers.iter().find_map(|layer| layer.metric.as_ref()))
                .filter(|x| !Python::with_gil(|py| x.is_none(py)));
            if let Some((next, prev)) = next_metric.zip(prev_metric) {
                let (diff, truthy) = Python::with_gil(|py| {
                    let diff = next.call_method1(py, pyo3::intern!(py, "__sub__"), (prev,))?;
                    let truthy = diff.is_truthy(py)?;
                    PyResult::Ok((diff, truthy))
                })?;
                if truthy {
                    println!("Evaluation evolved by {diff}!");
                }
            }
        }

        let totally_evaluated = inner.results.iter().all(|x| x.is_some());

        if let Some(score) = self
            .pipeline
            .aggregate_vec(Python::with_gil(|py| {
                inner
                    .results
                    .iter()
                    .filter_map(|x| {
                        x.as_ref().map(|x| {
                            clone_evaluation_result(py, x)
                                .into_pyobject(py)
                                .map(|x| x.into_any().unbind())
                        })
                    })
                    .collect::<PyResult<_>>()
            })?)
            .await?
        {
            if totally_evaluated {
                println!("Score: {score}");
            } else {
                println!("Partial Score: {score}");
                println!("Please run `aqora test` to get final score!");
            }
        }

        Ok(())
    }

    pub fn get_input(&self) -> PyResult<PyObject> {
        let inner = self.inner.read();
        let pending = inner
            .pending
            .as_ref()
            .ok_or_else(|| PyErr::new::<PyRuntimeError, _>("no evaluation pending"))?;
        Ok(Python::with_gil(|py| {
            pending.eval_state.input.clone_ref(py)
        }))
    }

    pub fn get_context(&self) -> PyResult<PyObject> {
        let inner = self.inner.read();
        let pending = inner
            .pending
            .as_ref()
            .ok_or_else(|| PyErr::new::<PyRuntimeError, _>("no evaluation pending"))?;
        Ok(Python::with_gil(|py| {
            pending.eval_state.context.clone_ref(py)
        }))
    }

    pub fn set_output(&self, output: PyObject) {
        let mut inner = self.inner.write();
        if let Some(pending) = &mut inner.pending {
            pending.output = output;
        }
    }
}
